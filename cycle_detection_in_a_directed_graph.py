# -*- coding: utf-8 -*-
"""Cycle Detection in a Directed Graph.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cZWuOrkNk0taV6lkQAciACqcXJp_Gzl7
"""

def has_cycle(graph):
    """
    Return True if the directed graph contains a cycle, False otherwise.
    graph: dict or list-of-lists adjacency representation.
    """
    n = len(graph)
    visited = [False]*n
    rec_stack = [False]*n

    def dfs(v):
        visited[v] = True
        rec_stack[v] = True
        # Visit all neighbors.
        for u in graph[v]:
            if rec_stack[u]:
                # Found a back-edge to u in the current path -> cycle.
                return True
            if not visited[u]:
                if dfs(u):
                    return True
        # Backtrack: remove v from recursion stack.
        rec_stack[v] = False
        return False

    # Check each vertex (for disconnected graphs).
    for v in range(n):
        if not visited[v]:
            if dfs(v):
                return True
    return False

# Example usage:
graph1 = {0:[1,2], 1:[2], 2:[0,3], 3:[]}
print("Graph1 has cycle:", has_cycle(graph1))
graph2 = {0:[1,2], 1:[2], 2:[3], 3:[]}
print("Graph2 has cycle:", has_cycle(graph2))